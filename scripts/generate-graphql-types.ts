import fs from 'fs';
import path from 'path';
import {
  GraphQLEnumType,
  GraphQLInputType,
  GraphQLNamedType,
  GraphQLObjectType,
  GraphQLOutputType,
  GraphQLScalarType,
  isEnumType,
  isListType,
  isNonNullType,
  isObjectType,
  isScalarType,
} from 'graphql';
import '../server/models';
import schema from '../server/schema/schema';
import { logger } from '../server/services/logger';

const OUTPUT_DIRECTORIES = [
  path.join(process.cwd(), 'shared', 'types', 'graphql', 'generated'),
  path.join(process.cwd(), 'client', 'src', 'types', 'generated', 'graphql'),
];

const SCALAR_TYPE_MAPPING: Record<string, string> = {
  ID: 'string',
  String: 'string',
  Int: 'number',
  Float: 'number',
  Boolean: 'boolean',
  Email: 'string',
  URL: 'string',
  Date: 'string',
};

const ensureDirectory = (directory: string): void => {
  if (!fs.existsSync(directory)) {
    fs.mkdirSync(directory, { recursive: true });
  }
};

const isScalarLike = (type: GraphQLOutputType): boolean => {
  if (isNonNullType(type) || isListType(type)) {
    return isScalarLike(type.ofType);
  }
  return isScalarType(type) || isEnumType(type);
};

const mapNamedTypeToTs = (namedType: GraphQLNamedType): string => {
  if (isScalarType(namedType)) {
    return SCALAR_TYPE_MAPPING[namedType.name] ?? 'string';
  }
  if (isEnumType(namedType)) {
    const values = namedType.getValues().map((value) => `'${value.name}'`);
    return values.length > 0 ? values.join(' | ') : 'string';
  }
  return 'string';
};

const mapOutputTypeToTs = (type: GraphQLOutputType): string => {
  if (isNonNullType(type)) {
    return mapOutputTypeToTsNonNull(type.ofType);
  }
  return `${mapOutputTypeToTsNonNull(type)} | null`;
};

const mapOutputTypeToTsNonNull = (type: GraphQLOutputType): string => {
  if (isNonNullType(type)) {
    return mapOutputTypeToTsNonNull(type.ofType);
  }
  if (isListType(type)) {
    return `Array<${mapOutputTypeToTs(type.ofType)}>`;
  }
  return mapNamedTypeToTs(type);
};

const mapInputTypeToTs = (type: GraphQLInputType): string => {
  if (isNonNullType(type)) {
    return mapInputTypeToTsNonNull(type.ofType);
  }
  return `${mapInputTypeToTsNonNull(type)} | null`;
};

const mapInputTypeToTsNonNull = (type: GraphQLInputType): string => {
  if (isNonNullType(type)) {
    return mapInputTypeToTsNonNull(type.ofType);
  }
  if (isListType(type)) {
    return `Array<${mapInputTypeToTs(type.ofType)}>`;
  }
  return mapNamedTypeToTs(type);
};

const getObjectType = (typeName: string): GraphQLObjectType => {
  const namedType = schema.getType(typeName);
  if (!namedType || !isObjectType(namedType)) {
    throw new Error(`Expected GraphQL object type "${typeName}" to exist.`);
  }
  return namedType;
};

const renderScalarProjection = (typeName: string, exportName: string): string => {
  const objectType = getObjectType(typeName);
  const fields = objectType.getFields();
  const lines = Object.values(fields)
    .filter((field) => isScalarLike(field.type))
    .map((field) => `  ${field.name}: ${mapOutputTypeToTs(field.type)};`);

  return `export interface ${exportName} {\n${lines.join('\n')}\n}\n`;
};

const renderVariablesInterface = (
  interfaceName: string,
  fieldName: 'animalsConnection' | 'applicationsConnection'
): string => {
  const queryType = schema.getQueryType();
  if (!queryType) {
    throw new Error('Schema query type is not defined.');
  }

  const field = queryType.getFields()[fieldName];
  if (!field) {
    throw new Error(`Expected query field "${fieldName}" to exist.`);
  }

  const lines = field.args.map((arg) => {
    const optional = isNonNullType(arg.type) ? '' : '?';
    return `  ${arg.name}${optional}: ${mapInputTypeToTs(arg.type)};`;
  });

  return `export interface ${interfaceName} {\n${lines.join('\n')}\n}\n`;
};

const renderConnectionsTypes = (): string => {
  const content = [
    '/* This file is generated by scripts/generate-graphql-types.ts. */',
    '',
    renderScalarProjection('AnimalType', 'AnimalRecord'),
    renderScalarProjection('ApplicationType', 'ApplicationRecord'),
    'export interface PageInfo {',
    '  endCursor: string | null;',
    '  hasNextPage: boolean | null;',
    '}',
    '',
    'export interface AnimalEdge {',
    '  cursor: string | null;',
    '  node: AnimalRecord | null;',
    '}',
    '',
    'export interface AnimalConnection {',
    '  edges: Array<AnimalEdge | null> | null;',
    '  pageInfo: PageInfo | null;',
    '  totalCount: number | null;',
    '}',
    '',
    'export interface ApplicationEdge {',
    '  cursor: string | null;',
    '  node: ApplicationRecord | null;',
    '}',
    '',
    'export interface ApplicationConnection {',
    '  edges: Array<ApplicationEdge | null> | null;',
    '  pageInfo: PageInfo | null;',
    '  totalCount: number | null;',
    '}',
    '',
    renderVariablesInterface('AnimalsConnectionQueryVariables', 'animalsConnection'),
    renderVariablesInterface('ApplicationsConnectionQueryVariables', 'applicationsConnection'),
    'export interface AnimalsConnectionQuery {',
    '  animalsConnection: AnimalConnection | null;',
    '}',
    '',
    'export interface ApplicationsConnectionQuery {',
    '  applicationsConnection: ApplicationConnection | null;',
    '}',
    '',
  ];

  return `${content.join('\n')}\n`;
};

const writeFile = (directory: string, fileName: string, content: string): void => {
  ensureDirectory(directory);
  fs.writeFileSync(path.join(directory, fileName), content, 'utf8');
};

export const generateGraphQLTypes = (): void => {
  const connectionsContent = renderConnectionsTypes();
  const indexContent = "export * from './connections';\n";

  for (const directory of OUTPUT_DIRECTORIES) {
    writeFile(directory, 'connections.ts', connectionsContent);
    writeFile(directory, 'index.ts', indexContent);
  }

  logger.info('graphql_types_generated', {
    outputs: OUTPUT_DIRECTORIES.length,
  });
};

if (process.env.NODE_ENV !== 'test') {
  generateGraphQLTypes();
}
